/*
  Dokan : user-mode file system library for Windows

  Copyright (C) 2018 Google, Inc.
  http://dokan-dev.github.io

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU Lesser General Public License as published by the Free
Software Foundation; either version 3 of the License, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along
with this program. If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DOKAN_UTIL_H_
#define DOKAN_UTIL_H_

#include <ntstatus.h>
#include <windows.h>

#include <cassert>
#include <chrono>
#include <codecvt>
#include <condition_variable>
#include <functional>
#include <memory>
#include <ostream>
#include <string>
#include <vector>

#include "api.h"
#include "kernel_defs.h"

namespace dokan {

class Logger;

namespace util {

using NarrowingConverter =
    std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>>;

// Determines whether a file name without a path matches a search pattern that
// may contain wildcards. The matching is always case-insensitive. This behaves
// like the FsRtlIsNameInExpression function in the kernel. The pattern is
// uppercased by the constructor as that function requires.
class FileNameMatcher {
 public:
  FileNameMatcher() {}
  FileNameMatcher(const FileNameMatcher&) = delete;
  FileNameMatcher& operator=(const FileNameMatcher&) = delete;
  DOKANCC_API ~FileNameMatcher();

  DOKANCC_API bool Init(const std::wstring& pattern);
  DOKANCC_API bool Matches(const std::wstring& file_name);
 private:
  UNICODE_STRING pattern_ = {0};
};

// Rounds value up to the next value divisible by block_size.
DOKANCC_API int64_t Align(size_t block_size, int64_t value);

// Performs the following sanitizations, non-recursively, if needed:
// Replace initial "\\" with '\'
// Delete terminating '\'
inline std::wstring SanitizePath(const std::wstring& path) {
  size_t start = 0;
  size_t end = path.size();
  if (path.size() > 1 && path[0] == '\\' && path[1] == '\\') {
    ++start;
  }
  if (path.size() > 2 && path[path.size() - 1] == '\\')  {
    --end;
  }
  return path.substr(start, end);
}

// Removes the last path component from the given path and returns a path string
// that does not end with a separator unless it would otherwise be empty.
inline std::wstring StripLastPathComponent(const std::wstring& path) {
  size_t index = path.rfind('\\');
  // It should already be a "sanitized" path.
  assert(index != path.size() - 1 || path.size() == 1);
  if (index == std::string::npos) {
    index = path.rfind('/');
  }
  if (index == 0 || index == std::string::npos) {
    return L"\\";
  }
  return path.substr(0, index);
}

// Strips the last path component of the given path and replaces it with the
// given name. Example: path = \foo\bar, name = xyz, return = \foo\xyz
inline std::wstring ReplaceLastPathComponent(const std::wstring& path,
                                             const std::wstring& name) {
  assert(path.size() > 1);
  std::wstring stripped = StripLastPathComponent(path);
  assert(!stripped.empty());
  return stripped.size() == 1 ? (stripped + name) : (stripped + L'\\' + name);
}

// Splits the alternate stream name, if any, from the rest of a path.
// - If path is in the form dir\file:stream, then this function sets
//   path = dir\file and stream_key = stream
// - Otherwise, it sets stream_key = "" and leaves path intact.
inline void SplitAlternateStreamName(std::wstring* path,
                                     std::wstring* stream_name) {
  size_t colon_index = path->find(':');
  if (colon_index == std::string::npos) {
    *stream_name = L"";
    return;
  }
  *stream_name = path->substr(colon_index + 1);
  *path = path->substr(0, colon_index);
}

// Converts a device name generated by the driver, in the format \Volume{guid},
// into a prefixed path that works with CreateFile and similar functions.
inline std::wstring MakeDevicePath(const std::wstring& device_name) {
  assert(!device_name.empty() && device_name[0] == L'\\');
  return std::wstring(L"\\\\?") + device_name;
}

// Creates a subpath string under a device name. The subpath may or may not
// begin with a blackslash.
inline std::wstring MakeDevicePath(const std::wstring& device_name,
                                   const std::wstring& subpath) {
  if (subpath.empty() || subpath[0] == '\\') {
    return MakeDevicePath(device_name) + subpath;
  }
  return MakeDevicePath(device_name) + L'\\' + subpath;
}

// MountPoint Drive letter used in dokancc are formated as C:
inline bool IsMountPointDriveLetter(const std::wstring& mount_point) {
  if (mount_point.empty() || mount_point.size() > 3) {
    return false;
  }
  const char letter = std::toupper(mount_point[0]);
  if (letter < 'A' || letter > 'Z') {
    return false;
  }
  if (mount_point.size() > 1 && mount_point[1] != ':') {
    return false;
  }
  if (mount_point.size() > 2 && mount_point[2] != '\\') {
    return false;
  }
  return true;
}

// Checks that the given driver version (presumably from the kernel) matches the
// version compiled into this library. If not, logs an error including both GUID
// strings to the given logger, and returns false.
DOKANCC_API bool CheckDriverVersion(const GUID& driver_version, Logger* logger);

// Sets a bool-like flag to true and signals a related condition variable.
template <typename T>
void SetAndNotify(std::mutex* mutex, std::condition_variable* cond, T* flag) {
  {
    std::unique_lock<std::mutex> lock(*mutex);
    *flag = true;
  }
  cond->notify_all();
}

inline void TimeToLargeInteger(const FILETIME& source, LARGE_INTEGER* dest) {
  dest->LowPart = source.dwLowDateTime;
  dest->HighPart = source.dwHighDateTime;
}

inline void LargeIntegerToTime(const LARGE_INTEGER& source, FILETIME* dest) {
  dest->dwLowDateTime = source.LowPart;
  dest->dwHighDateTime = source.HighPart;
}

// Runs the given function using the shared global narrowing string converter,
// with a mutex locked for the duration of the call. Returns true unless an
// exception is thrown (e.g. if there is a mismatched surrogate pair in a
// string being converted). Prefer using Narrow() instead of this function.
DOKANCC_API bool UseNarrowingConverter(
    const std::function<void(NarrowingConverter*)>&);

// Converts a UTF-16 std::wstring to UTF-8 std::string, returning whether it was
// successful. This only fails if there are invalid multi-word sequences in the
// input string.
inline bool Narrow(const std::wstring& str, std::string* out) {
  return UseNarrowingConverter([&](NarrowingConverter* converter) {
    *out = converter->to_bytes(str);
  });
}

// Converts a UTF-16 wide string to UTF-8 std::string, returning whether it was
// successful. This only fails if there are invalid multi-word sequences in the
// input string.
inline bool Narrow(const wchar_t* str, std::string* out) {
  return UseNarrowingConverter(
      [&](NarrowingConverter* converter) { *out = converter->to_bytes(str); });
}

using StatusCallback = std::function<void (NTSTATUS)>;

// Deletes a variable-sized struct that is backed by a char array.
template <typename T>
void DeleteVarStruct(T* x) {
  delete [] reinterpret_cast<char*>(x);
}

// A unique pointer to a variable-sized struct that is backed by a char array.
template <typename T>
using UniqueVarStructPtr = std::unique_ptr<T, decltype(&DeleteVarStruct<T>)>;

// Creates a zero-initialized variable length struct of type T backed by a
// buffer of the given size, and returns a unique pointer to it.
template <typename T>
UniqueVarStructPtr<T> MakeUniqueVarStruct(size_t size) {
  UniqueVarStructPtr<T> ptr(
      reinterpret_cast<T*>(new char[size]), &DeleteVarStruct<T>);
  memset(ptr.get(), 0, size);
  return ptr;
}

// Converts an existing raw pointer to a var-sized struct of type T into a
// unique pointer, with no modification of the object.
template <typename T>
UniqueVarStructPtr<T> MakeUniqueVarStruct(T* raw) {
  return UniqueVarStructPtr<T>(raw, &DeleteVarStruct<T>);
}

inline uint64_t CurrentWallTimeMs() {
  return std::chrono::duration_cast<std::chrono::milliseconds>(
             std::chrono::steady_clock::now().time_since_epoch())
      .count();
}

}  // namespace util

// Inserts a UTF-16 std::wstring to an ostream, converting it to UTF-8
// std::string first. If the conversion fails, it falls back to a truncating
// conversion.
inline std::ostream& operator<<(std::ostream& os, const std::wstring& str) {
  std::string out;
  if (util::Narrow(str, &out)) {
    return os << out;
  }
  return os << "<Failed to narrow: " << std::string(str.begin(), str.end())
            << ">";
}

// Inserts a UTF-16 wide string to an ostream, converting it to UTF-8
// std::string first. If the conversion fails, it falls back to a truncating
// conversion.
inline std::ostream& operator<<(std::ostream& os, const wchar_t* str) {
  std::string out;
  if (util::Narrow(str, &out)) {
    return os << out;
  }
  std::wstring wide = str;
  return os << "<Failed to narrow: " << std::string(wide.begin(), wide.end())
            << ">";
}

}  // namespace dokan

#endif // DOKAN_UTIL_H_
